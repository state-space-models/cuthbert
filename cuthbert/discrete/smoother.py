"""
Parallel-in-time Bayesian smoother for discrete hidden Markov models.

References:
    - https://ieeexplore.ieee.org/document/9512397
    - https://github.com/EEA-sensors/sequential-parallelization-examples/tree/main/python/temporal-parallelization-inference-in-HMMs
"""

from functools import partial
from typing import NamedTuple

import jax.numpy as jnp
from jax import tree

from cuthbert.discrete.filter import DiscreteFilterState
from cuthbert.discrete.types import GetTransitionMatrix
from cuthbert.inference import Smoother
from cuthbert.utils import dummy_tree_like
from cuthbertlib.discrete.smoothing import get_reverse_kernel, smoothing_operator
from cuthbertlib.types import Array, ArrayTree, ArrayTreeLike, KeyArray


class DiscreteSmootherState(NamedTuple):
    a: Array
    model_inputs: ArrayTree

    @property
    def dist(self):
        return jnp.take(self.a, 0, axis=-2)


def build_smoother(get_trans_matrix: GetTransitionMatrix) -> Smoother:
    r"""Builds a smoother object for discrete hidden Markov models.

    Args:
        get_trans_matrix: Function to get the transition matrix $A_{ij} = p(x_t = j \mid x_{t-1} = i)$.

    Returns:
        Smoother object. Suitable for associative scan.
    """
    return Smoother(
        convert_filter_to_smoother_state=convert_filter_to_smoother_state,
        smoother_prepare=partial(smoother_prepare, get_trans_matrix=get_trans_matrix),
        smoother_combine=smoother_combine,
        associative=True,
    )


def smoother_prepare(
    filter_state: DiscreteFilterState,
    get_trans_matrix: GetTransitionMatrix,
    model_inputs: ArrayTreeLike,
    key: KeyArray | None = None,
) -> DiscreteSmootherState:
    """Prepare a state for a smoother step.

    Args:
        filter_state: State generated by the filter at time t.
        get_trans_matrix: Function to get the transition matrix A_{ij} = p(x_{t+1} = j | x_{t} = i).
        model_inputs: Model inputs for the transition from t to t+1.
        key: JAX random key - not used.

    Returns:
        Prepared state for the smoother.
    """
    model_inputs = tree.map(lambda x: jnp.asarray(x), model_inputs)
    trans_matrix = get_trans_matrix(model_inputs)
    a = get_reverse_kernel(filter_state.dist, trans_matrix)
    return DiscreteSmootherState(a=a, model_inputs=model_inputs)


def convert_filter_to_smoother_state(
    filter_state: DiscreteFilterState,
    model_inputs: ArrayTreeLike | None = None,
    key: KeyArray | None = None,
) -> DiscreteSmootherState:
    """Convert a filter state to a smoother state.

    Useful for the final filter state which is equivalent to the final smoother state.

    Args:
        filter_state: Filter state.
        model_inputs: Only used to create an empty model_inputs tree (the values are ignored).
            Useful so that the final smoother state has the same structure as the rest.
            By default, filter_state.model_inputs is used. So this is only needed if the
            smoother model_inputs have a different tree structure to filter_state.model_inputs.
        key: JAX random key - not used.

    Returns:
        Smoother state, same data as filter state just different structure.
            Note that the model_inputs are set to dummy values.
    """
    if model_inputs is None:
        model_inputs = filter_state.model_inputs

    dummy_model_inputs = dummy_tree_like(model_inputs)

    filter_dist = filter_state.dist
    a = jnp.tile(filter_dist, (filter_dist.shape[0], 1))
    return DiscreteSmootherState(a=a, model_inputs=dummy_model_inputs)


def smoother_combine(
    state_1: DiscreteSmootherState, state_2: DiscreteSmootherState
) -> DiscreteSmootherState:
    """Combine the smoother state from the next time point with the state
    prepared with the latest model inputs.

    Remember smoothing iterates backwards in time.

    Args:
        state_1: State prepared with model inputs at time t.
        state_2: Smoother state at time t + 1.

    Returns:
        Combined smoother state.
    """
    a = smoothing_operator(state_1.a, state_2.a)
    return DiscreteSmootherState(a=a, model_inputs=state_1.model_inputs)
