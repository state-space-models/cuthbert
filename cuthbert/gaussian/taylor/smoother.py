"""Linearized Kalman smoother that uses automatic differentiation to extract
conditonally Gaussian parameters from log densities of the dynamics and observation
distributions. This differs from gaussian/moments which requires mean and chol_cov
functions as input rather than log densities.

I.e. we approximate conditional log densities as

log p(y | x) ≈ N(y | H x + d, L L^T)

and log potentials as

log G(x) ≈ N(x | m, L L^T)

where L is the cholesky factor of the covariance matrix.

See `cuthbertlib.linearize` for more details.
"""

from functools import partial

from jax import numpy as jnp
from jax import tree

from cuthbert.gaussian.kalman import (
    KalmanSmootherState,
    convert_filter_to_smoother_state,
    smoother_combine,
)
from cuthbert.gaussian.taylor.types import (
    GetDynamicsLogDensity,
)
from cuthbert.gaussian.types import (
    LinearizedKalmanFilterState,
)
from cuthbert.inference import Smoother
from cuthbertlib.kalman import smoothing
from cuthbertlib.linearize import linearize_log_density
from cuthbertlib.types import (
    ArrayTreeLike,
    KeyArray,
)


def build_smoother(
    get_dynamics_log_density: GetDynamicsLogDensity,
) -> Smoother:
    """
    Build linearized Taylor Kalman inference smoother.

    Args:
        get_dynamics_log_density: Function to get dynamics log density log p(x_t+1 | x_t)
            and linearization points (for the previous and current time points)

    Returns:
        Linearized Taylor Kalman smoother object, suitable for associative scan.
    """
    return Smoother(
        smoother_prepare=partial(
            smoother_prepare, get_dynamics_log_density=get_dynamics_log_density
        ),
        smoother_combine=smoother_combine,
        convert_filter_to_smoother_state=convert_filter_to_smoother_state,
        associative=True,
    )


def smoother_prepare(
    filter_state: LinearizedKalmanFilterState,
    get_dynamics_log_density: GetDynamicsLogDensity,
    model_inputs: ArrayTreeLike,
    key: KeyArray | None = None,
) -> KalmanSmootherState:
    """
    Prepare a state for a linearized Taylor Kalman smoother step.

    Args:
        filter_state: State generated by the linearized Taylor Kalman filter at the previous
            time point.
        get_dynamics_log_density: Function to get dynamics log density log p(x_t+1 | x_t)
            and linearization points (for the previous and current time points)
        model_inputs: Model inputs for the transition from t to t+1.
        key: JAX random key - not used.

    Returns:
        Prepared state for the Kalman smoother.
    """
    model_inputs = tree.map(lambda x: jnp.asarray(x), model_inputs)

    filter_mean = filter_state.mean
    filter_chol_cov = filter_state.chol_cov

    log_dynamics_density, linearization_point_prev, linearization_point_curr = (
        get_dynamics_log_density(filter_state, model_inputs)
    )

    F, c, chol_Q = linearize_log_density(
        log_dynamics_density, linearization_point_prev, linearization_point_curr
    )

    state = smoothing.associative_params_single(
        filter_mean, filter_chol_cov, F, c, chol_Q
    )
    return KalmanSmootherState(elem=state, gain=state.E, model_inputs=model_inputs)
