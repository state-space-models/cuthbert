"""Linearized Kalman smoother that takes a user provided conditional mean and
chol_cov functions to define a conditionally linear Gaussian state space model.

I.e. we approximate conditional log densities as

log p(y | x) â‰ˆ N(y | mean(x), chol_cov(x) @ chol_cov(x)^T)

See `cuthbertlib.linearize` for more details.

Parallelism via `associative_scan` is supported, but requires the `state` argument
to be ignored in `get_dynamics_params`.
I.e. the linearization points are pre-defined or extracted from model inputs.
"""

from functools import partial

from jax import numpy as jnp
from jax import tree

from cuthbert.gaussian.kalman import (
    KalmanSmootherState,
    convert_filter_to_smoother_state,
    smoother_combine,
)
from cuthbert.gaussian.moments.types import GetDynamicsMoments
from cuthbert.gaussian.types import LinearizedKalmanFilterState
from cuthbert.inference import Smoother
from cuthbertlib.kalman import smoothing
from cuthbertlib.linearize import linearize_moments
from cuthbertlib.types import ArrayTreeLike, KeyArray


def build_smoother(
    get_dynamics_params: GetDynamicsMoments,
) -> Smoother:
    """
    Build linearized moments Kalman inference smoother for conditionally Gaussian SSMs.

    Args:
        get_dynamics_params: Function to get dynamics conditional mean and
            (generalised) Cholesky covariance from linearization point and model inputs.

    Returns:
        Linearized moments Kalman smoother object, suitable for associative scan.
    """
    return Smoother(
        smoother_prepare=partial(
            smoother_prepare, get_dynamics_params=get_dynamics_params
        ),
        smoother_combine=smoother_combine,
        convert_filter_to_smoother_state=convert_filter_to_smoother_state,
        associative=True,
    )


def smoother_prepare(
    filter_state: LinearizedKalmanFilterState,
    get_dynamics_params: GetDynamicsMoments,
    model_inputs: ArrayTreeLike,
    key: KeyArray | None = None,
) -> KalmanSmootherState:
    """
    Prepare a state for an extended Kalman smoother step.

    Note that the model_inputs here are different to filter_state.model_inputs.
    The model_inputs required here are for the transition from t to t+1.
    filter_state.model_inputs represents the transition from t-1 to t.

    Args:
        filter_state: State generated by the extended Kalman filter at time t.
        get_dynamics_params: Function to get dynamics conditional mean and
            (generalised) Cholesky covariance from linearization point and model inputs.
        model_inputs: Model inputs for the transition from t to t+1.
        key: JAX random key - not used.

    Returns:
        Prepared state for the Kalman smoother.
    """
    model_inputs = tree.map(lambda x: jnp.asarray(x), model_inputs)
    filter_mean = filter_state.mean
    filter_chol_cov = filter_state.chol_cov

    dynamics_mean_and_chol_cov_func, dynamics_linearization_point = get_dynamics_params(
        filter_state, model_inputs
    )

    F, c, chol_Q = linearize_moments(
        dynamics_mean_and_chol_cov_func, dynamics_linearization_point
    )

    state = smoothing.associative_params_single(
        filter_mean, filter_chol_cov, F, c, chol_Q
    )
    return KalmanSmootherState(elem=state, gain=state.E, model_inputs=model_inputs)
